'use server';
import { generateRegistrationSchema } from '../../../config/registrationSchema';
import { createClient } from '@/lib/supabase/server';
import { revalidatePath } from 'next/cache';
import { redirect } from 'next/navigation';
// Removed import { headers } from 'next/headers'; as it causes issues when action is used by client components
import { z } from 'zod'; // For validation
import { fetchRegistrationByUserId, insertRegistration, RegistrationInput } from '@/lib/data/registrations';
import { Database, Json } from '@/lib/supabase/database.types'; // Import generated types including Json



const RegistrationSchema = generateRegistrationSchema(); // Removed export
// Define an inferred type based on the Zod schema
type ValidatedRegistrationData = z.infer<typeof RegistrationSchema>;

// Removed outdated hardcoded RegistrationSchema definition.
// The schema is now generated by the SSOT script and imported/exported on line 13.

// Type for state used by useFormState
export type RegistrationState = {
  errors?: {
    // Use Zod's error map type for better compatibility
    [key: string]: string[] | undefined;
    _form?: string[]; // For general form errors not specific to a field
  };
  message?: string | null;
  success: boolean;
};

export async function submitRegistration(
  previousState: RegistrationState,
  formData: FormData
): Promise<RegistrationState> {
  console.log("Submitting registration..."); // Add log
  const supabase = await createClient();
  // Removed headersList and origin usage

  // --- Data Processing ---
  // Process form data, handling arrays and special types
  const processedData: Record<string, any> = {};

  // Handle basic fields and potentially duplicated array fields
  formData.forEach((value, key) => {
    // Check if the key indicates an array (e.g., 'prior_courses')
    if (key.endsWith('[]')) { // Or use a more robust check based on known array fields
        const actualKey = key.replace('[]', '');
        if (!processedData[actualKey]) {
            processedData[actualKey] = [];
        }
        processedData[actualKey].push(value);
    } else if (formData.getAll(key).length > 1) {
        // Handle cases where multiple simple inputs have the same name (shouldn't happen with unique IDs)
        // Or handle actual array fields submitted without '[]' convention
        if (!processedData[key]) {
            processedData[key] = formData.getAll(key);
        }
    } else if (!processedData[key]) {
        // Handle single value fields
        processedData[key] = value;
    }
  });

  // Ensure known array fields are arrays even if only one value was submitted
  const arrayFields = ['prior_courses', 'philosophical_traditions', 'philosophical_interests'];
  for (const field of arrayFields) {
      if (processedData[field] && !Array.isArray(processedData[field])) {
          processedData[field] = [processedData[field]];
      } else if (!processedData[field]) {
          processedData[field] = []; // Ensure empty array if nothing selected
      }
  }


  // Extract email early for user check/sign-up
  const email = processedData.email;
  if (!email || typeof email !== 'string' || !email.includes('@')) {
    return { success: false, message: 'Invalid email address provided.' };
  }

  // Convert boolean fields from string before validation
  const booleanFields = ['code_of_conduct_agreement', 'photo_consent', 'data_privacy_consent'];
  booleanFields.forEach((field) => {
      if (processedData[field] === 'true') {
          processedData[field] = true;
      } else if (processedData[field] === 'false') {
          processedData[field] = false;
      } else {
           // Handle cases where it might be undefined or missing if not required
           // Zod will catch if required field is missing/undefined
           // If optional, undefined might be acceptable
           if (processedData.hasOwnProperty(field)) {
                processedData[field] = undefined; // Or handle as error if unexpected value
           }
      }
  });


  // Validate with Zod
  const validatedFields = RegistrationSchema.safeParse(processedData);

  if (!validatedFields.success) {
    console.log("Validation Errors:", validatedFields.error.flatten().fieldErrors);
    return {
      success: false,
      errors: validatedFields.error.flatten().fieldErrors,
      message: 'Validation failed. Please check the fields.',
    };
  }

  // Assert the type after successful validation
  const registrationData = validatedFields.data as ValidatedRegistrationData;

  // --- User Handling (V2 - Assume user created via signUpUser earlier) ---
  const { data: { user }, error: userError } = await supabase.auth.getUser();

  if (userError || !user) {
      console.error("User fetch error:", userError);
      return { success: false, message: 'Authentication error: Could not retrieve user.' };
  }
  const userId = user.id;

   // Optional: Verify email matches if needed, though getUser should be sufficient
   // const email = processedData.email; // Already extracted above
   // if (user.email !== email) {
   //   return { success: false, message: 'Email mismatch error.' };
   // }


  // Check for existing registration for this user
  try {
    const { registration: existingRegistration, error: checkError } = await fetchRegistrationByUserId(userId);
    if (checkError) throw checkError;
    if (existingRegistration) {
      // Instead of erroring, maybe update? For now, prevent duplicate submission.
      console.warn(`User ${userId} attempted to submit registration again.`);
      // Redirect to success as if it worked, or show a specific message?
      // For now, let's redirect to success, assuming they might have refreshed.
      redirect('/register/success');
      // return { success: false, message: 'You have already submitted your registration.' };
    }
  } catch (error: any) {
    console.error("DB Check Error:", error);
    return { success: false, message: 'Database error checking registration status.' };
  }

  // Prepare data for Supabase insertion (use validated data from V2 Zod schema)
  // Map V2 fields to V1.1 RegistrationInput fields expected by the DAL
  // Prepare data for Supabase insertion (use validated data from V3.1 Zod schema)
  // Map validated data to the updated RegistrationInput type
  const dataToInsert: RegistrationInput = {
      user_id: userId,
      // Personal Information
      firstName: registrationData.firstName,
      lastName: registrationData.lastName,
      email: registrationData.email,
      academicYear: registrationData.academicYear,
      academicYearOther: registrationData.academicYearOther,
      universityInstitution: registrationData.universityInstitution,
      programOfStudy: registrationData.programOfStudy,
      // Philosophy Background
      philosophyCoursework: registrationData.philosophyCoursework,
      philosophyConfidenceDiscussion: registrationData.philosophyConfidenceDiscussion,
      philosophyConfidenceWriting: registrationData.philosophyConfidenceWriting,
      philosophyTraditions: registrationData.philosophyTraditions,
      philosophyTraditionsOther: registrationData.philosophyTraditionsOther,
      philosophyInterests: registrationData.philosophyInterests,
      philosophyInterestsOther: registrationData.philosophyInterestsOther,
      philosophyInfluences: registrationData.philosophyInfluences,
      // Working Style & Preferences
      workingStyle: registrationData.workingStyle,
      workingStyleOther: registrationData.workingStyleOther,
      communicationStyle: registrationData.communicationStyle,
      collaborationRole: registrationData.collaborationRole,
      collaborationRoleOther: registrationData.collaborationRoleOther,
      presentationComfort: registrationData.presentationComfort,
      previousCollaborationExperience: registrationData.previousCollaborationExperience,
      previousCollaborationExperienceOther: registrationData.previousCollaborationExperienceOther,
      // Technical Background
      technicalFamiliarity: registrationData.technicalFamiliarity,
      technicalInterests: registrationData.technicalInterests,
      hackathonExperience: registrationData.hackathonExperience,
      hackathonExperienceDetails: registrationData.hackathonExperienceDetails,
      // Communication & Community
      discordMember: registrationData.discordMember,
      discordUsername: registrationData.discordUsername,
      // Logistics & Consent
      availability: registrationData.availability,
      availabilityDetails: registrationData.availabilityDetails,
      dietaryRestrictions: registrationData.dietaryRestrictions,
      accessibilityNeeds: registrationData.accessibilityNeeds,
      codeOfConductAgreement: registrationData.codeOfConductAgreement,
      photoConsent: registrationData.photoConsent,
      dataPrivacyConsent: registrationData.dataPrivacyConsent,
      finalConfirmation: registrationData.finalConfirmation,
  };


  // Insert data into Supabase
  try {
    const { error: insertError } = await insertRegistration(dataToInsert);
    if (insertError) throw insertError;

  } catch (error: any) {
    console.error('Registration Insert Error:', error);
    return { success: false, message: `Database Error: Failed to save registration. ${error.message}` };
  }

  // Revalidate relevant paths
  revalidatePath('/admin/registrations'); // Admin view

  // Redirect to success page after successful insertion
  redirect('/register/success');

  // Note: Redirect throws an error, so code below is unreachable but good practice for type checking
  // return { success: true, message: 'Registration submitted successfully!' };
}


// New action specifically for XState machine invocation
export async function submitRegistrationFromMachine(
  answers: Record<string, any> // Accept processed answers directly
): Promise<{ success: boolean; message: string | null }> { // Return simple status
  console.log("Submitting registration from machine...");
  const supabase = await createClient();

  // --- User Authentication ---
  const { data: { user }, error: userError } = await supabase.auth.getUser();
  if (userError || !user) {
    console.error("User fetch error:", userError);
    return { success: false, message: 'Authentication error: Could not retrieve user.' };
  }
  const userId = user.id;

  // --- Validation ---
  // Assume answers object already contains processed data (booleans converted etc.)
  // If not, add processing logic here similar to submitRegistration
  const validatedFields = RegistrationSchema.safeParse(answers);

  if (!validatedFields.success) {
    console.log("Machine Validation Errors:", validatedFields.error.flatten().fieldErrors);
    // Construct a user-friendly error message from Zod errors
    const errorMessages = Object.values(validatedFields.error.flatten().fieldErrors)
        .flat()
        .filter(Boolean) // Remove undefined/empty strings
        .join(' ');
    return {
      success: false,
      message: `Validation failed: ${errorMessages || 'Please check your answers.'}`,
    };
  }
  const registrationData = validatedFields.data as ValidatedRegistrationData;

  // --- Check for existing registration ---
  try {
    const { registration: existingRegistration, error: checkError } = await fetchRegistrationByUserId(userId);
    if (checkError) throw checkError;
    if (existingRegistration) {
      console.warn(`User ${userId} attempted to submit registration again via machine.`);
      // Treat as success if already submitted
      return { success: true, message: 'Registration already submitted.' };
    }
  } catch (error: any) {
    console.error("DB Check Error:", error);
    return { success: false, message: 'Database error checking registration status.' };
  }

  // --- Prepare data for insertion ---
  // Explicitly map fields from validated Zod data (registrationData) to RegistrationInput type
  const dataToInsert: RegistrationInput = {
      user_id: userId,
      // Personal Information
      firstName: registrationData.firstName,
      lastName: registrationData.lastName,
      email: registrationData.email,
      academicYear: registrationData.academicYear,
      academicYearOther: registrationData.academicYearOther,
      universityInstitution: registrationData.universityInstitution,
      programOfStudy: registrationData.programOfStudy,
      // Philosophy Background
      philosophyCoursework: registrationData.philosophyCoursework,
      philosophyConfidenceDiscussion: registrationData.philosophyConfidenceDiscussion,
      philosophyConfidenceWriting: registrationData.philosophyConfidenceWriting,
      philosophyTraditions: registrationData.philosophyTraditions,
      philosophyTraditionsOther: registrationData.philosophyTraditionsOther,
      philosophyInterests: registrationData.philosophyInterests,
      philosophyInterestsOther: registrationData.philosophyInterestsOther,
      philosophyInfluences: registrationData.philosophyInfluences,
      // Working Style & Preferences
      workingStyle: registrationData.workingStyle,
      workingStyleOther: registrationData.workingStyleOther,
      communicationStyle: registrationData.communicationStyle,
      collaborationRole: registrationData.collaborationRole,
      collaborationRoleOther: registrationData.collaborationRoleOther,
      presentationComfort: registrationData.presentationComfort,
      previousCollaborationExperience: registrationData.previousCollaborationExperience,
      previousCollaborationExperienceOther: registrationData.previousCollaborationExperienceOther,
      // Technical Background
      technicalFamiliarity: registrationData.technicalFamiliarity,
      technicalInterests: registrationData.technicalInterests,
      hackathonExperience: registrationData.hackathonExperience,
      hackathonExperienceDetails: registrationData.hackathonExperienceDetails,
      // Communication & Community
      discordMember: registrationData.discordMember,
      discordUsername: registrationData.discordUsername,
      // Logistics & Consent
      availability: registrationData.availability,
      availabilityDetails: registrationData.availabilityDetails,
      dietaryRestrictions: registrationData.dietaryRestrictions,
      accessibilityNeeds: registrationData.accessibilityNeeds,
      codeOfConductAgreement: registrationData.codeOfConductAgreement,
      photoConsent: registrationData.photoConsent,
      dataPrivacyConsent: registrationData.dataPrivacyConsent,
      finalConfirmation: registrationData.finalConfirmation,
  };
  // Note: Ensure the database schema for 'registrations' table matches these fields.

  // --- Database Insert ---
  try {
    // Pass the correctly typed data directly to the DAL function
    const { error: insertError } = await insertRegistration(dataToInsert);
    if (insertError) throw insertError;
    console.log(`Registration inserted successfully for user ${userId} via machine.`);
    // Revalidation should be handled by the caller if needed
    return { success: true, message: 'Registration submitted successfully!' };
  } catch (error: any) {
    console.error('Registration Insert Error (Machine):', error);
    return { success: false, message: `Database Error: Failed to save registration. ${error.message}` };
  }
}



// Action to check if a profile exists for the current user
export async function checkUserProfileExists(): Promise<{ success: boolean; profileExists: boolean; message?: string }> {
  const supabase = await createClient();

  // Get current user
  const { data: { user }, error: userError } = await supabase.auth.getUser();
  if (userError || !user) {
    console.error("User fetch error in checkUserProfileExists:", userError);
    return { success: false, profileExists: false, message: 'Authentication error: Could not retrieve user.' };
  }

  // Fetch profile
  const { fetchUserProfile } = await import('@/lib/data/profiles');
  const { profile, error: profileError } = await fetchUserProfile(user.id);

  if (profileError) {
    // Check if the error is specifically 'Profile not found'
    if (profileError.message.includes("Profile not found")) {
      console.log(`Profile not found for user ${user.id}, proceeding with registration questions.`);
      return { success: true, profileExists: false }; // Profile doesn't exist, this is a success case for the flow
    } else {
      // Handle other database errors
      console.error("Profile fetch error in checkUserProfileExists:", profileError);
      return { success: false, profileExists: false, message: `Database error: ${profileError.message}` };
    }
  }

  // Profile exists
  console.log(`Profile found for user ${user.id}.`);
  return { success: true, profileExists: true };
}


// Placeholder for email sending logic (to be implemented or called via trigger)
// async function sendConfirmationEmail(email: string, name: string) {
//   console.log(`Sending confirmation email to ${email} for ${name}...`);
//   // Add actual email sending logic here using Resend, SendGrid, etc.
// }


// Added updateRegistration action
export async function updateRegistration(
  previousState: RegistrationState,
  formData: FormData
): Promise<RegistrationState> {
  console.log("Updating registration...");
  const supabase = await createClient();

  // --- User Authentication ---
  const { data: { user }, error: userError } = await supabase.auth.getUser();
  if (userError || !user) {
    console.error("User fetch error:", userError);
    return { success: false, message: 'Authentication error: Could not retrieve user.' };
  }
  const userId = user.id;

  // --- Data Processing ---
  const processedData: Record<string, any> = {};
  formData.forEach((value, key) => {
    // Basic processing, similar to submitRegistration
    // TODO: Refactor processing logic into a shared helper function
    if (key.endsWith('[]')) {
        const actualKey = key.replace('[]', '');
        if (!processedData[actualKey]) processedData[actualKey] = [];
        processedData[actualKey].push(value);
    } else if (formData.getAll(key).length > 1) {
        if (!processedData[key]) processedData[key] = formData.getAll(key);
    } else if (!processedData[key]) {
        processedData[key] = value;
    }
  });
  const arrayFields = ['prior_courses', 'philosophical_traditions', 'philosophical_interests'];
   for (const field of arrayFields) {
       if (processedData[field] && !Array.isArray(processedData[field])) {
           processedData[field] = [processedData[field]];
       } else if (!processedData[field]) {
           processedData[field] = [];
       }
   }
   // Ensure email is included if it's part of the update form (it might not be)
   if (!processedData.email && user.email) {
       processedData.email = user.email;
   }
 
    // Convert boolean fields from string before validation
    const booleanFieldsUpdate = ['code_of_conduct_agreement', 'photo_consent', 'data_privacy_consent'];
    booleanFieldsUpdate.forEach((field) => {
        if (processedData[field] === 'true') {
            processedData[field] = true;
        } else if (processedData[field] === 'false') {
            processedData[field] = false;
        } else {
             if (processedData.hasOwnProperty(field)) {
                  processedData[field] = undefined;
             }
        }
    });
 
 
   // --- Validation ---
   // Use the same generated schema for validation
   const validatedFields = RegistrationSchema.safeParse(processedData);
 
   if (!validatedFields.success) {
    console.log("Update Validation Errors:", validatedFields.error.flatten().fieldErrors);
    return {
      success: false,
      errors: validatedFields.error.flatten().fieldErrors,
      message: 'Validation failed. Please check the fields.',
    };
  }

  // Assert the type after successful validation
  const registrationData = validatedFields.data as ValidatedRegistrationData;

  // --- Database Update ---
  try {
    // Use the DAL function
    // Import updateRegistrationById from DAL
    const { updateRegistrationById } = await import('@/lib/data/registrations');

    // Explicitly map fields for update, mapping V3.1 Zod data to the updated RegistrationInput type
    const dataToUpdate: Partial<RegistrationInput> = {
        // Personal Information
        firstName: registrationData.firstName,
        lastName: registrationData.lastName,
        email: registrationData.email, // Assuming email might be updatable, though unlikely
        academicYear: registrationData.academicYear,
        academicYearOther: registrationData.academicYearOther,
        universityInstitution: registrationData.universityInstitution,
        programOfStudy: registrationData.programOfStudy,
        // Philosophy Background
        philosophyCoursework: registrationData.philosophyCoursework,
        philosophyConfidenceDiscussion: registrationData.philosophyConfidenceDiscussion,
        philosophyConfidenceWriting: registrationData.philosophyConfidenceWriting,
        philosophyTraditions: registrationData.philosophyTraditions,
        philosophyTraditionsOther: registrationData.philosophyTraditionsOther,
        philosophyInterests: registrationData.philosophyInterests,
        philosophyInterestsOther: registrationData.philosophyInterestsOther,
        philosophyInfluences: registrationData.philosophyInfluences,
        // Working Style & Preferences
        workingStyle: registrationData.workingStyle,
        workingStyleOther: registrationData.workingStyleOther,
        communicationStyle: registrationData.communicationStyle,
        collaborationRole: registrationData.collaborationRole,
        collaborationRoleOther: registrationData.collaborationRoleOther,
        presentationComfort: registrationData.presentationComfort,
        previousCollaborationExperience: registrationData.previousCollaborationExperience,
        previousCollaborationExperienceOther: registrationData.previousCollaborationExperienceOther,
        // Technical Background
        technicalFamiliarity: registrationData.technicalFamiliarity,
        technicalInterests: registrationData.technicalInterests,
        hackathonExperience: registrationData.hackathonExperience,
        hackathonExperienceDetails: registrationData.hackathonExperienceDetails,
        // Communication & Community
        discordMember: registrationData.discordMember,
        discordUsername: registrationData.discordUsername,
        // Logistics & Consent
        availability: registrationData.availability,
        availabilityDetails: registrationData.availabilityDetails,
        dietaryRestrictions: registrationData.dietaryRestrictions,
        accessibilityNeeds: registrationData.accessibilityNeeds,
        codeOfConductAgreement: registrationData.codeOfConductAgreement,
        photoConsent: registrationData.photoConsent,
        dataPrivacyConsent: registrationData.dataPrivacyConsent,
        finalConfirmation: registrationData.finalConfirmation,
        // Note: user_id is handled by the .eq() clause and should not be in the update payload
    };

    const { registration: updatedReg, error: updateError } = await updateRegistrationById(userId, dataToUpdate);

    if (updateError) throw updateError;

    console.log(`Registration updated for user ${userId}`);

  } catch (error: any) {
    console.error('Registration Update Error:', error);
    return { success: false, message: `Database Error: Failed to update registration. ${error.message}` };
  }

  // --- Revalidation & Redirect ---
  revalidatePath('/register'); // Revalidate the main register page (where view/edit might be)
  // Optionally revalidate admin path if needed: revalidatePath('/admin/registrations');
  redirect('/register/success?updated=true'); // Redirect to success page with update flag

  // return { success: true, message: 'Registration updated successfully!' }; // Unreachable due to redirect
}


// Added deleteRegistration action
export async function deleteRegistration(): Promise<RegistrationState> {
    console.log("Deleting registration...");
    const supabase = await createClient();

    // --- User Authentication ---
    const { data: { user }, error: userError } = await supabase.auth.getUser();
    if (userError || !user) {
        console.error("User fetch error:", userError);
        return { success: false, message: 'Authentication error: Could not retrieve user.' };
    }
    const userId = user.id;

    // --- Database Deletion ---
    try {
        // Use the DAL function
        // Import deleteRegistrationByUserId from DAL
        const { deleteRegistrationByUserId } = await import('@/lib/data/registrations');
        const { success, error: deleteError } = await deleteRegistrationByUserId(userId);
        if (deleteError) throw deleteError;

        console.log(`Registration deleted for user ${userId}`);

    } catch (error: any) {
        console.error('Registration Delete Error:', error);
        return { success: false, message: `Database Error: Failed to delete registration. ${error.message}` };
    }

    // --- Revalidation & Redirect ---
    revalidatePath('/register'); // Revalidate the main register page
    // Optionally revalidate admin path: revalidatePath('/admin/registrations');
    redirect('/register'); // Redirect back to the main register page after deletion

    // return { success: true, message: 'Registration deleted successfully.' }; // Unreachable
}


// Type for state for the simple interest form
export type LogInterestState = {
  message: string | null;
  success: boolean;
};

// Server action for the simple interest form
export async function logInterest(
  previousState: LogInterestState,
  formData: FormData
): Promise<LogInterestState> {
  const email = formData.get('email');

  // Basic validation
  if (!email || typeof email !== 'string' || !email.includes('@')) {
    return { success: false, message: 'Please enter a valid email address.' };
  }

  const supabase = await createClient();

  try {
    console.log(`Attempting to log interest for: ${email}`);

    const { error } = await supabase
      .from('interest_signups')
      .insert({ email: email });

    if (error) {
        // Check for unique constraint violation (duplicate email)
        if (error.code === '23505') {
            console.warn(`Duplicate interest signup attempt for: ${email}`);
            // Treat duplicate as success, inform user they are already registered
            return { success: true, message: `You've already registered interest with ${email}. We'll keep you updated!` };
        }
        // Handle other errors
        console.error('Supabase Insert Error:', error);
        throw new Error(error.message);
    }

    console.log(`Successfully logged interest for: ${email}`);
    return { success: true, message: `Thank you! We'll notify ${email} when registration opens.` };

  } catch (error: any) {
    console.error('Log Interest Error:', error);
    return { success: false, message: `Failed to record interest: ${error.message}` };
  }
}



/**
 * Checks the email confirmation status of the currently authenticated user.
 * @returns A Promise resolving to true if the email is confirmed, false otherwise.
 */
export async function checkCurrentUserConfirmationStatus(): Promise<boolean> {
  try {
    const supabase = await createClient();
    const { data: { user }, error: userError } = await supabase.auth.getUser();

    if (userError) {
      console.error('Error fetching user for confirmation check:', userError);
      return false;
    }

    if (!user) {
      console.warn('No user found for confirmation check.');
      return false;
    }

    // Check if the email_confirmed_at timestamp exists and is valid
    return !!user.email_confirmed_at;

  } catch (error) {
    console.error('Unexpected error during confirmation status check:', error);
    return false;
  }
}
