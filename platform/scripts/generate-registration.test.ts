import { describe, it, expect, beforeAll, afterAll, vi } from 'vitest';
import fs from 'fs';
import path from 'path';
import { execSync } from 'child_process';
import { registrationSchema } from '../config/registrationSchema'; // For checks

// --- Configuration ---
const platformDir = path.resolve(__dirname, '..'); // Assumes script is in platform/scripts
const frontendQuestionsPath = path.resolve(platformDir, 'src/app/register/data/registrationQuestions.ts');
const actionsPath = path.resolve(platformDir, 'src/app/register/actions.ts');
const migrationsDir = path.resolve(platformDir, '../supabase/migrations'); // Path relative to platform dir

// Store original file contents and track created files
let originalActionsContent: string | null = null;
let generatedMigrationFile: string | null = null;
const generatedFrontendFile = frontendQuestionsPath; // This file is always overwritten

describe('SSOT Registration Generation Script', () => {
  beforeAll(() => {
    // Store original actions content if it exists
    if (fs.existsSync(actionsPath)) {
      originalActionsContent = fs.readFileSync(actionsPath, 'utf-8');
    }
    // Clean up potentially existing generated files from previous runs (optional)
    if (fs.existsSync(generatedFrontendFile)) {
        fs.unlinkSync(generatedFrontendFile);
    }
    // Clean up previous generated migrations (be careful with this in real scenarios)
    const migrationFiles = fs.readdirSync(migrationsDir);
    migrationFiles.forEach(file => {
        if (file.includes('_update_registrations_table_generated.sql')) {
            fs.unlinkSync(path.join(migrationsDir, file));
            console.log(`Cleaned up previous migration: ${file}`);
        }
    });

    // Run the script via npm
    try {
      console.log('Running generation script...');
      execSync('npm run generate:reg', { cwd: platformDir, stdio: 'inherit' });
      console.log('Generation script finished.');

      // Find the generated migration file
      const newMigrationFiles = fs.readdirSync(migrationsDir);
      generatedMigrationFile = newMigrationFiles.find(file => file.includes('_update_registrations_table_generated.sql')) || null;
      if (generatedMigrationFile) {
        generatedMigrationFile = path.join(migrationsDir, generatedMigrationFile);
      }

    } catch (error) {
      console.error('Failed to run generation script:', error);
      // Throw error to fail the test suite if script execution fails
      throw new Error(`Generation script failed: ${error}`);
    }
  });

  afterAll(() => {
    // Restore original actions file content
    if (originalActionsContent !== null) {
      fs.writeFileSync(actionsPath, originalActionsContent, 'utf-8');
      console.log(`Restored original content of ${path.basename(actionsPath)}`);
    } else if (fs.existsSync(actionsPath)) {
      // If the file was created by the script and didn't exist before
      // fs.unlinkSync(actionsPath);
      // console.log(`Removed generated ${path.basename(actionsPath)}`);
      // Decide if cleanup is needed - for now, let's leave it if it was created
    }

    // Clean up generated frontend file
    if (fs.existsSync(generatedFrontendFile)) {
        fs.unlinkSync(generatedFrontendFile);
        console.log(`Cleaned up generated ${path.basename(generatedFrontendFile)}`);
    }
    // Clean up generated migration file
    if (generatedMigrationFile && fs.existsSync(generatedMigrationFile)) {
        fs.unlinkSync(generatedMigrationFile);
        console.log(`Cleaned up generated migration: ${path.basename(generatedMigrationFile)}`);
    }
  });

  it('should generate the registrationQuestions.ts file', () => {
    expect(fs.existsSync(frontendQuestionsPath)).toBe(true);
  });

  it('should generate correct content in registrationQuestions.ts', () => {
    const content = fs.readFileSync(frontendQuestionsPath, 'utf-8');
    // Basic checks - more specific checks can be added
    expect(content).toContain('// Generated by generate-registration.ts');
    expect(content).toContain('export const questions: Question[] = [');
    expect(content).toContain('export type FormDataStore = {');
    // Check if a known question ID is present
    expect(content).toContain("id: 'fullName'");
    // Check if password fields are excluded
    expect(content).not.toContain("id: 'password'");
    expect(content).not.toContain("id: 'confirmPassword'");
    // clientValidation is correctly excluded as confirmPassword is not in the output
  });

   it('should update actions.ts with schema import and usage', () => {
     expect(fs.existsSync(actionsPath)).toBe(true); // Ensure file exists
     const content = fs.readFileSync(actionsPath, 'utf-8');
     // Check for import (adjust path as needed based on script logic)
     expect(content).toContain("import { generateRegistrationSchema } from '../config/registrationSchema';");
     // Check for schema usage
     expect(content).toContain('export const RegistrationSchema = generateRegistrationSchema();');
   });

  it('should generate a draft SQL migration file', () => {
    expect(generatedMigrationFile).not.toBeNull();
    expect(fs.existsSync(generatedMigrationFile!)).toBe(true);
  });

  it('should generate plausible content in the SQL migration file', () => {
    const content = fs.readFileSync(generatedMigrationFile!, 'utf-8');
    expect(content).toContain('-- Draft migration generated by generate-registration.ts');
    expect(content).toContain('ALTER TABLE public.registrations');
    // Check if columns from the schema (excluding SKIP) are mentioned
    registrationSchema.forEach(q => {
        if (q.dbType !== 'SKIP') {
            expect(content).toContain(`"${q.id}"`); // Check for quoted column name
        }
    });
    expect(content).toContain('ADD CONSTRAINT registrations_user_id_fkey'); // Check for FK constraint
  });
});