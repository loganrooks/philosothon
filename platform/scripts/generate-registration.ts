import fs from 'fs';
import path from 'path';
// Correct the import path relative to the script's location in platform/scripts/
import { registrationSchema, QuestionDefinition, generateRegistrationSchema as generateZodSchemaFromConfig } from '../config/registrationSchema';
import { z } from 'zod'; // Import Zod for schema generation logic

// --- Configuration ---
const frontendQuestionsPath = path.resolve(__dirname, '../src/app/register/data/registrationQuestions.ts');
const actionsPath = path.resolve(__dirname, '../src/app/register/actions.ts');
const migrationsDir = path.resolve(__dirname, '../../supabase/migrations');
// Use a more specific import path assuming '@/' maps to 'src/'
const zodSchemaImport = "import { generateRegistrationSchema } from '@/config/registrationSchema';";
const zodSchemaUsage = "export const RegistrationSchema = generateRegistrationSchema();"; // Ensure this matches usage in actions.ts

// --- Helper Functions ---

function generateFrontendQuestionsContent(): string {
  console.log("Generating content for registrationQuestions.ts...");

  // Define the Question interface expected by the frontend
  const questionInterface = `
// Define abstract types matching the central schema
export type QuestionType =
  | 'text'
  | 'textarea'
  | 'email'
  | 'password'
  | 'number'
  | 'boolean'
  | 'single-select'
  | 'multi-select';

export interface Question {
  id: string;
  label: string;
  type: QuestionType;
  required: boolean;
  placeholder?: string;
  options?: string[];
  dependsOn?: string;
  dependsValue?: any;
  clientValidation?: (value: any, allValues?: Record<string, any>) => string | undefined;
}
`;

  // Generate the questions array content, excluding password fields for frontend use
  const questionsArrayContent = registrationSchema
    .filter(q => q.type !== 'password' && q.id !== 'confirmPassword') // Exclude password fields
    .sort((a, b) => a.order - b.order) // Ensure order is maintained
    .map(q => {
      // Escape single quotes and backticks in labels and placeholders for safe string embedding
      const escapedLabel = q.label.replace(/['`]/g, "\\'");
      const escapedPlaceholder = q.placeholder?.replace(/['`]/g, "\\'");

      let questionObject = `  {
    id: '${q.id}',
    label: \`${escapedLabel}\`, // Use template literal for easier escaping
    type: '${q.type}',
    required: ${q.required},`;
      if (q.placeholder) {
        questionObject += `\n    placeholder: \`${escapedPlaceholder}\`,`;
      }
      if (q.options) {
        questionObject += `\n    options: ${JSON.stringify(q.options)},`;
      }
      if (q.dependsOn) {
        questionObject += `\n    dependsOn: '${q.dependsOn}',`;
      }
      if (q.dependsValue !== undefined) {
        questionObject += `\n    dependsValue: ${JSON.stringify(q.dependsValue)},`;
      }
       if (q.clientValidation) {
         // Stringify the client validation function if present
         // Note: This has limitations and might not work for complex closures.
         const funcString = q.clientValidation.toString();
         // Basic check to ensure it looks like a function string
         if (funcString.startsWith('function') || funcString.includes('=>')) {
            questionObject += `\n    clientValidation: ${funcString},`;
         } else {
            console.warn(`Could not stringify clientValidation for question '${q.id}'. Skipping.`);
         }
       }
      questionObject += `\n  }`;
      return questionObject;
    })
    .join(',\n');

  // Generate FormDataStore type
  const formDataStoreTypeContent = `
export type FormDataStore = {
${registrationSchema
  .filter(q => q.dbType !== 'SKIP') // Only include fields that are stored
  .map(q => `  ${q.id}?: any; // TODO: Refine types based on q.type`)
  .join('\n')}
  currentQuestionIndex?: number;
  isVerified?: boolean; // Track if email/password step is done
};
`;

  return `// Generated by generate-registration.ts. Do not edit manually.\n\n${questionInterface}\n\n${formDataStoreTypeContent}\n\nexport const questions: Question[] = [\n${questionsArrayContent}\n];\n`;
}

function ensureSchemaUsageInActions(): string {
    console.log(`Ensuring schema usage in ${path.basename(actionsPath)}...`);
    let content = fs.readFileSync(actionsPath, 'utf-8');
    let modified = false;

    // Ensure the import exists
    if (!content.includes(zodSchemaImport.replace('@/', '../'))) { // Adjust for relative path from actions.ts
        // Add the import at the top (simple approach)
        content = `${zodSchemaImport.replace('@/', '../')}\n${content}`; // Adjust path relative to actions.ts
        console.log(`Added schema import to ${path.basename(actionsPath)}.`);
        modified = true;
    } else {
        console.log(`Schema import already exists in ${path.basename(actionsPath)}.`);
    }

    // Ensure the schema is generated and exported
    // Replace existing schema definition if found, otherwise add it.
    const schemaRegex = /export\s+const\s+RegistrationSchema\s*=\s*z\.object\s*\({[\s\S]*?}\)(?:\.refine\([\s\S]*?\))?;?/gm;
    const schemaDefinition = `// Generated Zod schema based on central configuration\n${zodSchemaUsage}`;

    if (schemaRegex.test(content)) {
        content = content.replace(schemaRegex, schemaDefinition);
        console.log(`Replaced existing RegistrationSchema definition in ${path.basename(actionsPath)}.`);
        modified = true;
    } else if (!content.includes(zodSchemaUsage)) {
        // Attempt to add it after imports
        const importEndIndex = content.lastIndexOf('import ');
        const nextLineIndex = content.indexOf('\n', importEndIndex >= 0 ? importEndIndex : 0) + 1;
        content = content.slice(0, nextLineIndex) + `\n${schemaDefinition}\n` + content.slice(nextLineIndex);
        console.log(`Added schema usage export to ${path.basename(actionsPath)}.`);
        modified = true;
    } else {
         console.log(`Schema usage export already exists in ${path.basename(actionsPath)}.`);
    }

    // Return modified content only if changes were made
    return modified ? content : fs.readFileSync(actionsPath, 'utf-8');
}


function generateSqlMigrationContent(): { filename: string; content: string } {
  console.log("Generating draft SQL migration...");
  const timestamp = new Date().toISOString().replace(/[-:T.]/g, '').slice(0, 14);
  const filename = `${timestamp}_update_registrations_table_generated.sql`;

  let sqlContent = `-- Draft migration generated by generate-registration.ts at ${new Date().toISOString()}\n`;
  sqlContent += `-- Please review and adjust column types, constraints, and defaults before applying.\n\n`;
  sqlContent += `BEGIN;\n\n`;
  sqlContent += `-- Ensure the registrations table exists (adjust if needed)\n`;
  sqlContent += `-- CREATE TABLE IF NOT EXISTS public.registrations (\n`;
  sqlContent += `--   id UUID PRIMARY KEY DEFAULT gen_random_uuid(),\n`;
  sqlContent += `--   user_id UUID REFERENCES auth.users(id) ON DELETE CASCADE,\n`;
  sqlContent += `--   created_at TIMESTAMPTZ DEFAULT now(),\n`;
  sqlContent += `--   updated_at TIMESTAMPTZ DEFAULT now()\n`;
  sqlContent += `--   -- Add other base columns as needed\n`;
  sqlContent += `-- );\n\n`;

  sqlContent += `-- Add columns based on registrationSchema\n`;

  const columnsToAdd: string[] = [];
  registrationSchema.forEach(q => {
    if (q.dbType !== 'SKIP') {
      let columnDefinition = `ADD COLUMN IF NOT EXISTS "${q.id}"`; // Use quotes for potential reserved words
      switch (q.dbType) {
        case 'VARCHAR(255)':
          columnDefinition += ` VARCHAR(255)`;
          break;
        case 'INTEGER':
          columnDefinition += ` INTEGER`;
          break;
        case 'BOOLEAN':
          columnDefinition += ` BOOLEAN`;
          break;
        case 'TEXT[]':
          columnDefinition += ` TEXT[]`; // Assumes PostgreSQL array type
          break;
        case 'JSONB':
          columnDefinition += ` JSONB`;
          break;
        case 'TEXT':
        default:
          columnDefinition += ` TEXT`;
          break;
      }
      // Basic NOT NULL constraint - review if defaults are needed
      // Example: Add default for boolean consents?
      // if (q.required) {
      //   columnDefinition += ` NOT NULL`; // Be cautious adding NOT NULL without defaults to existing tables
      // }
      columnsToAdd.push(columnDefinition);
    }
  });

  if (columnsToAdd.length > 0) {
      sqlContent += `ALTER TABLE public.registrations\n`;
      sqlContent += columnsToAdd.map(col => `  ${col}`).join(',\n');
      sqlContent += `;\n\n`;
  } else {
      sqlContent += `-- No new columns to add based on schema dbType hints.\n\n`;
  }


  sqlContent += `-- Add/Update foreign key constraint to link registrations to users (if not already present)\n`;
  sqlContent += `ALTER TABLE public.registrations\n`;
  sqlContent += `  ADD COLUMN IF NOT EXISTS user_id UUID,\n`;
  sqlContent += `  ADD CONSTRAINT registrations_user_id_fkey FOREIGN KEY (user_id) REFERENCES auth.users(id) ON DELETE CASCADE;\n\n`;
  sqlContent += `-- Optional: Index on user_id\n`;
  sqlContent += `CREATE INDEX IF NOT EXISTS idx_registrations_user_id ON public.registrations(user_id);\n\n`;


  sqlContent += `COMMIT;\n`;

  return { filename, content: sqlContent };
}

// --- Main Execution ---

try {
  // 1. Generate and write frontend questions file
  const frontendContent = generateFrontendQuestionsContent();
  // Ensure directory exists
  fs.mkdirSync(path.dirname(frontendQuestionsPath), { recursive: true });
  fs.writeFileSync(frontendQuestionsPath, frontendContent, 'utf-8');
  console.log(`Successfully generated ${path.basename(frontendQuestionsPath)}`);

  // 2. Ensure schema usage in actions file
  const originalActionsContent = fs.existsSync(actionsPath) ? fs.readFileSync(actionsPath, 'utf-8') : '';
  const updatedActionsContent = ensureSchemaUsageInActions();
   if (updatedActionsContent !== originalActionsContent) {
       fs.writeFileSync(actionsPath, updatedActionsContent, 'utf-8');
       console.log(`Successfully updated ${path.basename(actionsPath)} with schema usage.`);
   } else {
        console.log(`${path.basename(actionsPath)} already up-to-date regarding schema usage.`);
   }


  // 3. Generate and write draft SQL migration
  const { filename: migrationFilename, content: migrationContent } = generateSqlMigrationContent();
  if (!fs.existsSync(migrationsDir)) {
    fs.mkdirSync(migrationsDir, { recursive: true });
    console.log(`Created migrations directory: ${migrationsDir}`);
  }
  const migrationPath = path.join(migrationsDir, migrationFilename);
  fs.writeFileSync(migrationPath, migrationContent, 'utf-8');
  console.log(`Successfully generated draft migration: ${migrationFilename}`);
  console.log("---");
  console.log("IMPORTANT: Review the generated migration file before applying it to your database!");
  console.log(`Migration file path: ${path.relative(process.cwd(), migrationPath)}`);
  console.log("---");


  console.log("SSOT generation script completed successfully.");

} catch (error) {
  console.error("Error running SSOT generation script:", error);
  process.exit(1);
}